클린 코드 책을 목차부터 '복간에 부쳐' ~ '들어가며'까지를 읽었을 때 진짜 과거의 내가 짠 코드들이 많이 부끄러워졌다.</br>
옮긴이인 박채호님이 옮긴이 서문에 작성했듯이 나 또한 현 재직 중인 회사에서(이직 예정 중) 프로젝트 마감에 쫓겨 허겁지겁 코딩하느라 코딩 개선을 못해 추후 유지보수를 하려고 하면 코드를 해석하는데 시간이 오래 걸리고 어떠한 기능을 수정하거나 추가했을 때 다른 부분에서 연쇄 에러가 발생한 경험을 많이 했었다.</br>
보이스카우트 규칙처럼 개발자는 **체크아웃해 코드를 꺼낼 때보다 체크인해서 코드를 넣을 때 더 깨끗한 상태로 만들어야할 의무가 있다**는 것을 잊지 말아야겠다.
</br></br>
* '복간에 부쳐'에서 모르는 용어
  * 기차 충돌 코드(train wreck)</br>
    아래 코드와 같이 여러 객체가 한 줄로 이어져서 보이는 코드(클린 코드 p.123 참고)
    <pre><code>final String outputDir = ctxt.getOptions().getScrachDir().getAbsolutePath()</code></pre>
  * <a href="https://ko.wikipedia.org/wiki/%ED%94%8C%EB%A3%A8%EC%96%B8%ED%8A%B8_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">fluent interface</a></br>
    소스 코드의 가독성을 산문과 유사하게 만드는게 목적인 메소드 체이닝에 상당 부분을 기반한 객체지향 API 메소드 설계법</br>
    => 메소드 체이닝: 메소드가 객체를 반환해 반환된 값으로 다른 메소드를 호출할 수 있게 작성하는 문법</br>
  * 린(Lean) 원칙</br>
    불필요한 낭비를 제거하자
    </br></br>
* 유지보수에 초엄을 둔 TPM(Total Projuctive Management) 원칙
  * 정리</br>
    적절한 명명법을 사용해 무엇이 어떤 것인지 이해할 수 있어야 한다.
  * 체계화</br>
    코드는 누구나 예상한 위치에 있어야 한다.
  * 정리</br>
    쓸데 없는 과거 이력이나 미래 바람을 기약하는 주석, 혹은 주석으로 처리한 부분은 제거해야 한다.
  * 표준화</br>
    조직원들이 동의한 일관적인 구현 스타일과 기법이 조직 내에 필요하다.
  * 생활화</br>
    규칙, 관례를 따르고 자주 코드를 돌아보고 고칠 곳이 있다면 고치는 것을 생활화 해야 한다.</br>
    (제품의 생명 주기를 고려해서)

</br></br>
 
**품질을 측정하는 유일한 척도 = 분달 내지르는 WTF!(What the fuck!) 횟수**
 
</br></br>

## 01. 깨끗한 코드
### 여러 저명한 사람들이 이야기한 클린 코드를 정리하면...
- 가독성이 좋아서 코드를 읽는 사람이 재밌게 읽을 수 있어야 한다.
- 한 가지 함수에는 한 가지 기능만 들어가게 추상화 해야 한다.
- TDD가 중요하다
- 의존성, 클래스, 메서드, 함수 등을 최소화 해 명확하게 작성해야 한다.
- 오류는 명백한 전략에 의해 철저하게 처리되어야 한다.
- 구현하고자 했던 기능을 각 루틴이 그대로 수행해야 한다.
- 모든 사항을 고려해 작성해야 한다. 즉, 모든 테스트에 통과해야 한다.
- 중복이 없어야 한다.
- 효율적이며 논리적이고 원칙이 있어야 한다.
</br>

### 모르는 용어
* DSL(Domain-Specific Language)
  특정한 도메인을 개발하기 위해 특화된 언어로 해당 문제를 해결하기 위해서는 해당 언어를 따로 배워야하는 단점이 있다.
* PPP(Agile Software Development : Principles, Patterns, and Practices)에 나오는 객체 지향 설계 다섯 가지 원칙</br>
  (클린 코드 저자가 클린 코드 다음으로 읽어보길 권하는 책)
  
  * SPR(The Sigle Responsibility Principle)
    클래스는 한 가지에 대해서만 정의되어야 한다. 즉, 클래스는 한 가지에 대해서만 책임을 진다.
  * OCP(The Open Closed Principle)
    클래스는 확장에 대해서는 열려 있어야 하며 변경에 대해서는 닫혀 있어야 한다.</br>
    예를 Enum으로 에러 코드를 정의했을 경우 추가적인 에러 코드를 정의하려면 에러 Enum을 수정해야하는데 이는 OCP를 위반한 것이다.
  * LSP(The Liskov Substitution)
    상속 받은 클래스는 기초 클래스를 대체할 수 있어야 한다.
  * DIP(The Dependency Inversion Principle)
    추상화에 의존해야 하며, 구체화에 의존하면 안 된다. 즉, 인터페이스에 의존해야 한다. 의존성 주입이 이 원칙을 따른다.
  * ISP(The Interface Segregration Principle)
    클라이언트에게 밀접하게 작게 쪼개진 인터페이스를 사용 한다. 즉, 범용 인터페이스를 사용하지 않는다.
    
</br></br>

정말 읽으면서 뼈를 엄청 맞았던 파트였다. 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이나 한 줄만 고치면 되리라 에상했다가 다른 모듈 수십 개를 건드렸던 것이나... 너무 공감되고 너무 뜨끔했다.</br>
</br>
그리고 결국 나쁜 코드를 작성하면(깨끗하지 않은 코드를 작성하면) 추후 그 코드를 해석하는데 더 많은 시간을 쏟아 붓고 결국 손도 댈 수 없게 되어 생산성이 0이 된다는 부분이 흥미로웠다.</br>
생산성이 0이 된다는 부분이 아마 si에서 느낄 수 있는 개발의 한계가 아닐까 싶다.</br>
</br>
또한 책에서는 결국 일정에 쫓기더라도 좋은 코드를 사수하는 것은 프로그래머들의 책임이라고하는게 과연 이게 현실적인 말일까 싶다.</br>
뒤에 있는 파트인 '03. 함수' 파트에서도 한 번에 좋은 함수를 짤 수는 없고 처음에 지저분하게 짜도 그것을 시간을 들여 고쳐서 깨끗한 코드로 만들어야 한다고 하는데 한국의 현실 si에서는 일정에 쫓겨 기본 기능 구현조차도 야근이며 주말 출근까지해가며 해내는데 그게 과연 프로그래머 개인만의 책임일까 싶다.</br>
</br>
깨끗한 코드라는 것은 결국 정리하자면 고심해서 작성하고 의존성을 최소화 하고 그 안에서 한 가지 기능만 충실히 행하며 다른 사람이 읽었을 때 해석하는데 무리가 없어야하는 코드를 의미하는 것 같다.</br>
결국 미래의 내가 읽어도 욕을 하지 않고 필요한 부분을 찾아서 고쳤을 때 문제가 없는 코드가 바로 깨끗한 코드가 아닐까?</br>

</br></br>

## 02. 의미 있는 이름
객체와 함수의 이름을 의미 있게 짓지 않으면 코드를 읽는 사람이 쉽게 코드를 이해할 수 없다.
</br></br>
* 의도를 분명히 밝혀라</br>
  주석으로 설명이 필요하다면 이는 이름으로 의도를 분명하게 밝히지 못한 것이다.
* 그릇된 정보를 피하라</br>
  accountList인데 List형이 아닌 것처럼 이름에 그릇된 정보를 넣지 말아라.</br>
  또한 소문자 L와 대문자 O로만 명명할 경우 숫자와 혼동될 수 있다.
* 의미 있게 구분하라</br>
  Product라는 객체가 있는데 ProductInfo라는 객체를 생성하면 둘은 크게 어떻게 다른지 알 수 없다.</br>
  이름에 variavle, String과 타입 명시는 하지 않는게 좋으며 불필요 하다.
* 발음하기 쉬운 이름</br>
  프로그래밍은 사회적 활동으로 회의에서 발음하기 어려우면 회의 진행도 어렵고 개발자가 기억하기도 힘들다.
* 검색하기 쉬운 이름
* 인코딩을 피하라
  * 헝가리 표기법</br>
    지금은 사용되지 않지만 옛날에 컴파일러가 타입을 점검하지 않아서 프로그래머가 직접 타입을 기억해야했을 때 변수 이름 앞에 타입 및 scope에 대한 접두사를 붙여 변수를 명명했던 방법</br>
  즉, 지금은 IDE에서 컴파일 하지 않고도 타입 에러를 감지할 수 있으므로 타입과 scope 정보와 같은 불필요한 정보를 이름에 넣지 말자.
* 자신의 기억을 자랑하지 마라</br>
  개개인이 무슨 뜻인지 별도로 기억해야 하는 이름은 사용하지 말자
* 클래스 이름</br>
  클래스 이름은 명사로 정의하자.</br>
  또한, Manager, Processor, Data, Info 등과 같이 특징을 나타낼 수 없는 명사는 사용하지 말자.
* 메소드 이름</br>
  동사, 동사구(get, set, is 접두사 사용)</br>
* 기발한 이름은 피하라
* 한 개념에 한 단어를 사용하라</br>
  하나의 프로젝트에서 Controller, Manager, Driver와 같이 비슷한 의미를 가진 단어를 섞어서 사용하지 말고 하나로 정해서 사용하라.
* 말장난을 하지 마라
* 해법 영역에서 가져온 이름을 사용하라</br>
  개발자라면 누구나 알만한 용어를 사용하라
* 문제 영역에서 가져온 이름을 사용하라</br>
  위의 해법 영역에서 가져올 만한 용어가 없을 경우 문제와 관련이 깊은 용어를 사용하라
* 의미 있는 맥락을 추가하라</br>
  firstName, lastName, state와 같이 그냥 있으면 정확히 어떤 것을 의미하는지 알 수 없는 단어 일 경우,</br>
  addr 접두사를 앞에 추가하거나 Address라는 클래스를 생성해 묶어라.
* 불필요한 맥락을 없애라

</br></br>

**좋은 이름으로 정의해도 코드를 사람의 교육, 문화적인 문제가 영향을 줘 코드 해석을 어렵게 할 수도 있다.**

</br></br>

명명하는 규칙 또한 위의 깨끗한 코드에서 이야기 했듯이 누군가 봤을 때 내가 명명해 놓은 의도를 쉽게 알아낼 수 있게 명명하는 것을 의미하는 것 같다.</br>
유지보수 하기 힘든 코드에서의 명명법과 반대로 하면 그게 바로 좋은 명명법이 아닐까.</br>

</br></br>


## 03. 함수
함수 또한 너무 크게 만들어 놓으면 그 안에 들어가는 로직이 많아 추후 유지보수가 힘들다.
나 또한 현 회사에서 프로젝트를 진행하면서 이 때문에 함수를 분리해 추상화 단계가 더 낮은 함수를 만들곤 했었다.
하지만 추상화 단계에 맞게 함수를 잘 나누는 것은 이론보다는 직접 하면서 익히는 경험이 더 많은 영향을 미치는 것 같다.
</br></br>
* 작게 만들어라</br>
  함수 안의 로직을 최대한 다른 함수로 쪼개는 것을 의미한다.</br>
  같은 맥락에서 if/else, while 문에 들어가는 코드는 들여쓰기 한 번으로 끝내도록 해야한다.
* 한 가지만 해라</br>
  함수 안에는 한 가지 기능에만 집중하게 만들고 그 안에 들어가는 다른 기능이 있다면 그것은 다른 별도 함수로 빼야 한다.</br>
  즉, 지정된 함수의 추상호 단계 수준이 하나인지 확인이 필요하다.
  * **추상화 수준이 와닿지 않을 경우** </br>
    해당 함수를 말로 풀어서 생각해보자.</br>
    말로 풀고 각 단계가 함수가 되고 하위로 갈 수록 추상화 단계가 낮아지는 것이다.</br>
    => 은행에 가서 계좌에서 돈을 뽑는다.</br>
        -- 계좌가 존재하는지 체크한다.</br>
          -- 계좌에서 돈을 뽑는다.</br>
            -- 계좌에서 돈을 뽑고 잔액을 계산한다.</br>
              -- 계좌에서 잔액이 마이너스인지 체크한다.</br>
* 함수 당 추상화 수준은 하나로!</br>
  위의 '한 가지만 해라'와 같은 뜻이다.</br>
  코드는 위에서 아래로 읽는(내려가기 규칙) 흐름으로 작성하며 아래로 내려갈 수록 추상화 수준이 낮아지도록 작성한다.</br>
* Switch 문</br>
  switch 문은 다형성 객체를 생성할 때 사용한다. (팩토리 패턴과 같은)
* 서술적인 이름을 사용하라!
* 함수 인수</br>
  인수는 없거나 적은 것이 좋다.</br>
  함수에 들어가는 인수가 많으면 해당 함수를 사용해야하는 개발자는 각 인수가 어떤 타입이고 유효한 값을 넣기 위해 고민해야 한다.</br>
  또한 테스트에서도 유효한 값을 하나 하나 넣기 번거로워진다.
  * 단항 함수</br>
    인수로 무언가 체크해야할 때, 인수를 변환해서 결과를 반환해야할 때, 인수로 인한 이벤트 발생 시킬 때 등 사용하자.</br>
    이벤트 발생도 아닌데 인수를 받는데 void 반환형을 사용하는 것은 바람직하지 않다.
  * 플래그 인수</br>
    함수가 한꺼번에 여러 가지를 처리하지 않는 이상 필요 없다.
  * 이항 함수</br>
    인수 2개가 하나의 값을 표현하는 경우나 자연적인 순서를 의미하는 경우에 사용하자.</br>
    불가피하게 사용할 수 있으나 되도록이면 두 인수를 하나의 객체로 묶어서 단항 함수로 변경하자.
  * 삼항 함수</br>
    그만한 가치가 있으면 보는 사람이 잠깐 해석을 위해 고민할지라도 사용하자.
  * 인수 객체</br>
    여러 인수를 하나의 클래스로 선언해 단항 함수로 만들자.
  * 인수 목록
    같은 타입의 인수를 여러 개 받는 경우라면 Object... args와 같이 인수를 받아 단항, 이항, 삼항 취급이 되도록 하자.</br>
    예) String.format(String format, Object... args)
  * 동사와 키워드</br>
    함수 이름에 인수 이름을 넣으면 더 함수를 이해하기 쉽다.
* 부수 효과를 일으키지 마라!</br>
  굳이 해당 함수에 필요 없는 기능을 넣었을 경우 부수 효과가 허용되는 특정 상황에서만 해당 함수를 사용할 수 있는 시간적인 결합을 초래한다.
  따라서 부수 효과가 있는 경우에는 함수 이름에 부수 효과를 명시해야 한다.
  * 출력 인수</br>
    생성한 클래스 객체를 인수로 받은 것을 변환하는 경우에는 별도 다른 클래스의 함수로 정의하기 보다는 해당 클래스(객체)의 함수로 정의하는 것이 좋다.
* 명령과 조회를 분리하라!
* 오류 코드보다는 예외를 사용
* Try/Catch 블록 뽑아내기</br>
  Try/Catch 안의 로직을 따로 함수로 분리해서 사용하는 것이 좋다.
* 오류 처리도 한 가지 작업 단위
* Error.Java 의존성 자석</br>
  열거형 등으로 오류 코드를 클래스에 넣어 사용할 경우 PPP책에서 이야기한 객체지향 규칙 중 OCP를 위반하게 된다.</br>
  또한 열거형에 오류 코드를 추가/수정/삭제 할 경우 새로 컴파일이 필요하다.</br>
  즉, 오류 코드로 명시하기보다는 Custom Exception을 생성해 사용하는 것이 좋다.
* 반복하지 마라
* 구조적 프로그래밍</br>
  큰 함수에서는 return이 하나여야 한다. 즉, loop 문 안에서 break나 continue를 사용해선 안 된다.</br>
  대신 큰 함수에서는 goto 문을 사용해도 괜찮다.

</br>

### 모르는 용어
* COP(component oriented programming)</br>
  시스템을 구성하는 구성 요소들을 하나로 조립해 하나의 새로운 응용 프로그램을 만드는 방법</br>
  예를 들어 쇼핑 사이트의 기능을 상업적으로 이용가능한 다른 곳의 컴포넌트를 가져와서 응용해 개발하는 방법</br>
  
</br></br>
추상단계에 대해서 내 말로 풀어서 설명을 다시 적어놓긴 했지만 아직 그렇게 와닿지는 않는다.</br>
이 부분은 앞으로 많은 실무를 경험하면서 쌓아야할 경험치 같다.</br>
또한 함수 파트에서는 하나의 시스템에서 모두 지키기 힘든 이상적인 이론들을 이야기하고 있으므로 실제 실무에서는 불가피하게 어기는 조언들도 몇몇 보였다.</br>
결국 이러한 조언들을 읽고 개발자가 판단해서 코드를 더 읽기 쉽게 함수를 구성해야하는 것이다.</br>
  
  
