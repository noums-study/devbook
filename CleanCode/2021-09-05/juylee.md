## 14. 점진적 개선
**깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 한다.**</br>

1. 점진적으로 개선하다.
* TDD는 변경을 가한 후에도 시스템 변경 전과 똑같이 돌아가야 한다.
* 새 인수 유형을 추가하려면 보통 세 곳(parse, get, set)을 변경해야 한다.
* 소프트웨어 설계는 분할만 잘 해도 품질이 크게 높아진다.

</br></br>
실제 예를 통해서 코드를 먼저 짜고 지저분한 코드를 정리하는 것을 설명해주는 장이다.</br>
덕분에 왜 이렇게 정리했는지 이해가 됐다.</br>
그리고 이번에도 내가 과거에 코딩했던 것들을 정리하지 않았던 것이 트끔하고 후회스러웠다.</br>
확실히 예전에 짠 코드를 다시 보면 더럽다는 것을 느끼는 것처럼 과거에 짰던 코드를 다시 돌아보고 리팩토링 하는 과정을 꼭 거쳐야 겠다.
</br></br>

## 15. JUnit 들여다보기
* 점진적 개선과 마찬가지로 이번에는 ComparisonCompactor 코드를 수정하는 과정을 절차적으로 잘 보여준다.
* 분석 함수가 먼저 나오고 조합 함수가 그 뒤를 이어서 나와야 좋다.
</br></br>

## 16. SerialDate 리팩터링

1. 돌려보자
* 코드 커버리지 분석 도구 클로버(Clover): 단위 테스트를 실행하는 코드와 실행하지 않는 코드 자동 조사
</br>

2. 고쳐보자
* Javadoc에서 모든 주석을 pre 태그로 표현하면 소스코드와 문서에 주석이 동일한 모양새로 표현되므로 좋다.
* 추상 클래스 이름에는 구현을 암시하지 않는 것이 좋다.
* serialVersionUID를 직접 선언하는 것보다는 자동 제어하는 것이 좋다. 하지만 직접 선언할 경우 사소한 변경을 했을 경우 이전 클래스를 복원하지 못하는 사태를 방지할 수 있다.
* 기반 클래스(base class, 부모 클래스)는 파생 클래스(derivative class, 자식 클래스)를 몰라야 한다.
* final 키워드는 final 상수 등 몇 군데를 제하면 별다른 가치가 없으면 코드를 복잡하게 만든다.

</br></br>

## 17. 냄새와 휴리스틱
1. 주석
* 부적절한 정보(일반적으로 작성자, 최종 수정일, SPR(Software Problem Report) 번호 등과 같은 메타 정보만 주석을 넣는다.)의 주석을 사용하지 않는다.
* 코드가 의미하는 것과 중복되는 것을 의미하는 없앤다.
* 주석을 성의 없이 작성하지 않는다.
* 주석 처리된 코드는 없앤다.
* 쓸모 없는 주석은 없앤다.
</br>

2. 환경
* 빌드는 간단히 한 단계로 끝나야 한다.
* 모든 단위테스트는 한 명령으로 돌려야 한다.
</br>

3. 함수
* 함수에서 인수 개수는 적을 수록 좋다.
* 출력 인수는 직관을 정면으로 위배한다.
* 플래스 인수는 혼란을 초래하므로 피해야 한다.
* 아무도 호출하지 않는 함수는 삭제한다.
</br>

4. 일반
* 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.
* 함수나 클래스는 당연하게 여길만한 동작과 기능을 제공해야 한다.
* 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라.
* 직접 제어나 컴파일러 경고 일부를 꺼버리는 것은 위험하고 끝없는 디버깅에 시달리게 할 수 있다.
* Template method 패턴이나 Strategy 패턴으로 중복을 제거하라.
* 추상화로 개념을 분리할 때 철저해야 한다.
* 기초 클래스는 파생 클래스를 몰라야 한다. 따라서 기초 클래스와 파생 클래스를 다른 jar 파일로 배포하는 것이 좋다.
* 클래스가 제공하는 메서드, 함수가 아는 변수는 적을 수록 좋다.
* 죽은 코드를 제거하라.
* 변수는 사용하기 직전에 선언하며 비공개 함수는 호출한 직후에 정의하라.
* 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현하라.
* 비어 있는 기본 생성자는 코드를 복잡하게 만든다.
* 서로 무관한 개념을 인위적으로 결합하지 않는다.
* 클래스 메서드는 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.
* 선택자(Selector) 인수는 목적을 기억하기 어려울 뿐 아니라 각 선택자 인수가 여러 함수를 하나로 조합하므로 좋지 않다.
* 코드를 짤 때는 의도를 최대한 분명히 밝힌다.
* 코드는 기대할 위치에 배치한다.
* 일반적으로 static 함수보다 인스턴스 함수가 더 좋다.
* 서술적인 변수 이름을 사용하자.
* 함수의 이름을 기능에 일치 시키게 지어라.
* 알고리즘을 이해하라.
* 놀리적 의존성은 물리적 의존성으로 바꿔라
* if/else 혹은 switch/case 문보다는 다형성을 사용하라
* 표준 표기법을 따르라.
* 의미가 분명하지 않은 숫자(숫자 뿐만 아니라 문자 등) 명명된 상수로 교체하라.
* 코드에서 뭔가를 결정할 때는 정확히 결정하라.
* 관례보다 구조를 사용하라.
* 조건을 캡술화해 명명해 의도를 분명히 밝혀라.
* 부정 조건은 피하라.
* 함수는 한 가지만 해야 한다.
* 필요한 시간적 결함은 명백히 드러내야 한다.
* 일관성을 유지하라.
* 경계 조건을 캡슐화 하라.
* 함수의 추상화 수준은 함수 이름이 의미하는 기능보다 한 단계 낮아야 한다.
* 설정 정보는 최상위 딘계에 둬라.
* 부끄럼 타는 코드 작성(writing shy code)을 피하라. = 디미터 법칙(law of demeter)를 피하라.
</br>

5. 자바
* 긴 import 대신 와일드카드를 사용하라. 와일드카드 import문은 의존성이 생기지 않는다.
* enum을 많이 사용하라.
</br>

6. 이름
* 서술적인 이름을 사용하라.
* 적절한 추상화 수준에서 이름을 선택하라.
* 가능하다면 표준 명명법(프로젝트의 유비쿼터스 언어(ubiquitous language))을 사용하라.
* 명확한 이름을 사용하라.
* 이름 길이는 범위 길이에 비례해야 한다.
* 헝가리안 표기법의 오염에서 이름을 보호하라.
* 함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용하라.
</br>

7. 테스트
* 테스트 케이스는 잠재적으로 깨질만한 부분을 모두 테스트 해야 한다.
* 커버리지 도구를 사용하라.
* 사소한 테스트를 건너뛰지 마라.
* 모호함이 존재하는 테스트 케이스는 컴파일이 가능한지 불가능한지 확인해보고 무시하라.
* 경계 조건을 테스트하라.
* 버그를 발견했다면 그 주변을 철저히 테스트 하라.
* 실패 패턴을 살펴라.

</br></br>
17장은 지금까지 1~16장에서 이야기했던 깨끗한 코드를 작성하는데에 필요한 일반적인 규칙들을 정리해놨다.(휴리스틱)</br>
냄새가 나는 코드는 아닌지(더러운 코드는 아닌지) 다시 정리하게 하고 있다.</br>
나중에 클린 코드에서 말했던 것들을 잊어먹고 다시 봐야 한다면 다른 장들을 전체적으로 훑는 것보다 먼저 17장을 읽고 나서 필요한 장을 살펴보는 것이 좋겠다.</br>

</br>
종합적으로 클린 코드 책은 깨끗한 코드를 작성하기 위한 이론서로 이 이론을 어디까지 받아들일 것이고 어떻게 응용할 것인지는 결국 코드를 작성하는 사람에게 달려 있는 것 같다.</br>
앞으로 클린 코드에서 읽었던 권고 사항들을 기억하고 깨끗한 코드를 작성하도록 노력해야겠다.
</br></br>
