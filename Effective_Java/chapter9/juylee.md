# 9장 일반적인 프로그래밍 원칙
## 지역변수의 범위를 최소화하라
지역변수의 범위를 줄이는 가장 강력한 기법은 역시 '가장 처음 쓰일 때 선언하기'다.</br>
거의 모든 지역변수는 선언과 동시에 초기화해야 한다.</br>
메서드를 작게 유지하고 한 가지 기능에 집중하자.</br>
</br></br>

## 전통적인 for 문보다는 for-each 문을 사용하라
```
for(Element e: elements) {
  ...
}
```
</br>
<i>for-each 문을 사용할 수 없는 상황</i>
</br>
* 파괴적 필터링(destructive filtering): 원소를 제거해야해서 컬렉션의 remove를 호출해야하는 상황(자바 8부터는 removeIf()를 이용해서 for-each 안에서도 원소 값으로 컬렉션에서 원소를 제거할 수 있다.)
* 변형(transforming): 원소의 값을 변경해야하는 경우라면 인덱스가 필요하다.
* 병렬 반복(parallel iteration): 여러 컬렉셔을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 염격하고 명시적으로 제어해야 한다.</br>
</br></br>

## 라이브러리를 익히고 사용하라
표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.</br>
자바 프로그래머라면 java.lan, java.util, java.io와 그 하위 패키지들에는 익숙해지는 것이 좋다.</br>
</br></br>

## 정확한 답이 필요하다면 float와 double은 피하라
float과 double은 0.1 혹은 10의 음의 거듭제곱 수를 표현할 수 없기 때문에 특히 금융 관련 게산과는 맞지 않는다.</br>
따라서 금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다.</br>
단, BigDecimal은 불편하고 기본 타입보다 느리고, int 혹은 long은 소수점을 직접 별도 관리해야한다는 단점이 있다.</br>
</br></br>

## 박싱된 기본 타입보다는 기본 타입을 사용하라
박싱된 기본 타입은 값이 아닌 별도 식별자를 가지므로 같은 값이어도 == 연산자를 사용하면 서로 같지 않다고 판단한다.</br>
기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.(Interger -> int)</br>
null 값을 가진 박싱 타입을 언박싱하면 NullPointException이 발생한다.</br>
</br></br>

## 다른 타입이 적절하다면 문자열 사용을 피하라
문자열든 다른 값 타입(열거 타입, 혼합 타입, 권한 등)을 대신하기에는 적합하지 않다.</br>
</br></br>

## 문자열 연결은 느리니 주의하라
성능을 포기하고 싶지 않다면 String 대신 StringBuilder를 사용하자.</br>
</br></br>

## 객체는 인터페이스를 사용해 참조하라
적합한 인터페이스가 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하는 것이 유연하다.</br>
적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자.</br>
</br></br>

## 리플렉션보다는 인터페이스를 사용하라
* 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
* 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
* 성능이 떨어진다.
</br>

컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 리플렉션을 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.</br>
</br></br>

## 네이티브 메서드는 신중히 사용하라
네이티브 메서드란 C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 의미한다.</br>
네이티브 메서드는 레지스트리 같은 플랙폼 특화 기능을 사용할 대나 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한 경우 사용하게 된다.</br>
하지만 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다.</br>
가비지 컬렉터는 네이티브 메모리는 자동 회수하지 못하고 추적도 할 수 없다.</br>
</br></br>

## 최적화는 신중히 하라
최적화는 빠르지도 않고 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시킬 수 있으니 빠른 프로그램보다는 좋은 프로그램을 작성하라.</br>
따라서 설계 단계에서 성능을 염두에 두어 성능을 제한하는 설계를 피해야 한다.</br>
API를 설계할 때 성능에 주는 영향을 고려하라.</br>
성능을 위해 잘 설계된 API를 왜곡하는 건 매우 안 좋은 생각이다.</br>
각각의 최적화 시도 전후로 성능을 측정하라.</br>
최적화 노력을 어디에 집중해야 할지 찾아주는 프로파일링 도구를 이용하자.</br>
</br></br>

## 일반적으로 통용되는 명명 규칙을 따르라
